Matrix::nearPD(A)
while (iter < 2) {
Y <- X
R <- Y - D_S
print(R)
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p))
stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
X
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
Y <- X
R <- Y - D_S
print(R)
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p))
stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
X
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
print(Q)
X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
print(rep(d[p], each = nrow(Q)))
X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
print(X)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
Q0 <- Q * rep(d[p], each = nrow(Q))
X <- tcrossprod(Q0, Q)
print(X)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
X
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
Q0 <- Q * rep(d[p], each = nrow(Q))
print(Q0)
X <- tcrossprod(Q0, Q)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
A<-matrix(0,ncol=3,nrow = 3)
A[1,1]<-A[2,2]<-A[3,3]<-1
A[1,2]<-A[2,1]<-3
A[1,3]<-A[3,1]<-2
A[2,3]<-A[3,2]<-4
#nearPD
eig.tol = 1e-06
conv.tol = 1e-07
posd.tol = 1e-08
maxit = 100
D_S <- A
D_S[] <- 0
X <- A
iter <- 0
converged <- FALSE
conv <- Inf
conv.norm.type<-"I"
do2eigen<-F
doDykstra<-T
keepDiag<-F
ensureSymmetry<- F
only.values<-F
x<-A
n <- ncol(x)
D_S <- x
D_S[] <- 0
X <- x
iter <- 0
converged <- FALSE
conv <- Inf
while (iter < 2) {
print(paste0("Iteracao ",iter))
Y <- X
R <- Y - D_S
e <- eigen(R, symmetric = TRUE)
Q <- e$vectors
d <- e$values
p <- d > eig.tol * d[1]
if (!any(p)) stop("Matrix seems negative semi-definite")
Q <- Q[, p, drop = FALSE]
Q0 <- Q * rep(d[p], each = nrow(Q))
X <- tcrossprod(Q0, Q)
print(X)
D_S <- X - R
conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
iter <- iter + 1
converged <- (conv <= conv.tol)
}
Matrix::nearPD
library(MASS)
error <- mvrnorm(1000, mu = c(0,0), Sigma = matrix(   2,-0.5,
-0.5, 4  ),byrow=T,ncol=2 )
error <- mvrnorm(1000, mu = c(0,0), Sigma = matrix(   2,-0.5,
-0.5, 4  ),byrow=T,ncol=2 ))
error <- mvrnorm(1000, mu = c(0,0), Sigma = matrix(c(2,-0.5,
-0.5, 4),byrow=T,ncol=2))
View(error)
library(MASS)
error <- mvrnorm(1000, mu = c(0,0), Sigma = matrix(c(2,-0.5,
-0.5, 4),byrow=T,ncol=2))
#Covariates
X1<-rnorm(1000,10,3)
X2<-rnorm(1000,5,4)
X3<-rnorm(1000,9,6)
#Simulate Residual
Y1<- +0.5+1*X1-2*X3+error[,1]
Y2<- -1.5+1*X1+0.8*X2+error[,2]
#Clean ethe Working Directory
rm(list=ls())
set.seed(17)
library(gtools)
#Working directory
setwd("C:\\Users\\p.albuquerque\\Dropbox\\Rlda\\tests\\Binomial Denis")
source('gibbs functions.R')
dat=data.matrix(read.csv('fake data.csv',as.is=T)[,-1])
#Number of communities
community <- 10
#Number of bands
bands<-ncol(dat)
#Number of locations
locations<-nrow(dat)
#priors
a1=1; a2=1
gamma=1
#initial values
Theta=matrix(1/community,locations,community)
Omega=matrix(runif(community*bands),bands,community)
#assign everybody to community 1
max.dat=max(dat)
zmat=expand.grid(comm=1,bands=1:bands,reflect=0:1,loc=1:locations,n=NA)
for (i in 1:bands){
cond=zmat$bands==i & zmat$reflect==1
zmat[cond,'n']=dat[,i]
cond=zmat$bands==i & zmat$reflect==0
zmat[cond,'n']=max.dat-dat[,i]
}
param=list(Theta=Theta,Omega=Omega,zmat=zmat)
ngibbs=1000
vec.omega=matrix(NA,ngibbs,community*bands)
vec.theta=matrix(NA,ngibbs,community*locations)
vec.loglikel=matrix(NA,ngibbs,1)
i<-1
tmp=update.Theta(param)
param$Theta=tmp$Theta
param$Vjl=tmp$Vjl
Theta=Vjl=matrix(NA,locations,community)
zmat=param$zmat
res=aggregate(n~comm+loc,data=zmat,sum)
View(res)
aux=expand.grid(loc=1:locations,comm=1:community)
View(aux)
res1=merge(res,aux,all=T)
View(res1)
cond=is.na(res1$n)
res1[cond,'n']=0
View(res1)
View(zmat)
View(res)
View(zmat)
l<-1
b<-1
dat[l,b]
rmultinom(1,size=dat[l,b],prob=prob1)
prob=param$Omega[b,]*param$Theta[l,]
prob1=prob/sum(prob)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(2,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
prob1
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
rmultinom(1,size=dat[l,b],prob=prob1)
max(dat)
View(zmat)
res=aggregate(n~comm+loc,data=zmat,sum)
View(res)
View(zmat)
sum(zmat$n[which(zmat$comm==1 & zmat$loc==1)])
sum(zmat$n[which(zmat$comm==1 & zmat$loc==2)])
sum(zmat$n[which(zmat$comm==2 & zmat$loc==2)])
View(zmat)
View(dat)
#for individuals that reflect, calculate prob of belonging to each community
prob=param$Omega[b,]*param$Theta[l,]
prob1=prob/sum(prob)
ztmp=rmultinom(1,size=dat[l,b],prob=prob1)
ztmp
ind=which(ztmp!=0)
ind
cbind(b,l,1,ind,ztmp[ind])
max.dat-dat[l,b]!=0
dat[l,b]!=0
res=aggregate(n~comm+loc,data=zmat,sum)
View(res)
tmp=update.Theta(param)
param$Theta=tmp$Theta
param$Vjl=tmp$Vjl
param$Omega=update.Omega(param)
param$zmat=update.zmat(param)
sum(zmat$n[which(zmat$comm==1 & zmat$loc==1)])
sum(param$zmat$n[which(param$zmat$comm==1 & param$zmat$loc==1)])
Theta=Vjl=matrix(NA,locations,community)
zmat=param$zmat
#calculate the number of individuals in each community and locations
res=aggregate(n~comm+loc,data=zmat,sum)
#make sure that empty communities have zeroes for 'n'
aux=expand.grid(loc=1:locations,comm=1:community)
res1=merge(res,aux,all=T)
cond=is.na(res1$n)
res1[cond,'n']=0
i<-1
cond=res1$comm==i
njl=res1[cond,'n']
njl
View(res)
cond=res1$comm==i
njl=res1[cond,'n']
cond=res1$comm>i
cond
cond=res1$comm>i
tmp=aggregate(n~loc,data=res1[cond,],sum)
View(tmp)
sum(tmp$n)
tmp$n
